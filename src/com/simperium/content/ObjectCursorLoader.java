/**
 * ObjectCursorLoader is an AsyncTaskLoader that takes care of managing an
 * ObjectCursor generated by a Query.
 * 
 * TODO: handle closing of the cursor
 * TODO: handle requerying and force reloading
 * TODO: listen to the bucket for changes to automatically deliver new results?
 */
package com.simperium.content;

import android.content.Context;
import android.content.AsyncTaskLoader;

import com.simperium.client.Bucket;
import com.simperium.client.Bucket.ObjectCursor;
import com.simperium.client.Query;
import com.simperium.client.Syncable;

import android.os.CancellationSignal;
import android.os.OperationCanceledException;

public class ObjectCursorLoader<T extends Syncable> extends AsyncTaskLoader<ObjectCursor<T>> {

    private Bucket<T> mBucket;
    private Query<T> mQuery;
    private ObjectCursor<T> mCursor;

    private CancellationSignal mCancellationSignal;

    public ObjectCursorLoader(Context context){
        super(context);
    }

    public ObjectCursorLoader(Context context, Query<T> query){
        this(context);
        setQuery(query);
    }

    public void setQuery(Query<T> query){
        mQuery = query;
    }

    public Query<T> getQuery(){
        return mQuery;
    }

    /**
     * Perform the bucket query on a background thread
     */
    @Override
    public ObjectCursor<T> loadInBackground(){
        // query the bucket and return an object cursor
        synchronized(this){
            // Check if loader has been cancelled
            if (isLoadInBackgroundCanceled()) {
                throw new OperationCanceledException();
            }
            mCancellationSignal = new CancellationSignal();
        }
        try {
            // execute the query and return the cursor
            ObjectCursor<T> cursor = mQuery.execute(mCancellationSignal);
            return cursor;
        } finally {
            synchronized(this){
                // clear the signal
                mCancellationSignal = null;
            }
        }
    }

    @Override
    public void deliverResult(ObjectCursor<T> cursor){
        // if the loader was reset before delivering result, cancel the load
        // and close the cursor
        if (isReset()) {
            if (cursor != null) {
                cursor.close();
            }
            return;
        }
        ObjectCursor oldCursor = mCursor;
        mCursor = cursor;

        if(isStarted()){
            super.deliverResult(cursor);
        }
        // delivering a new cursor, clean up the old cursor
        if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
            oldCursor.close();
        }
    }

    /**
     * Cancel load in send cancel signal to active CancellationSignal
     */
    @Override
    public void cancelLoadInBackground(){
        super.cancelLoadInBackground();
        synchronized(this){
            if (mCancellationSignal != null) {
                mCancellationSignal.cancel();
            }
        }
    }

    @Override
    public void onStartLoading(){
        // if we have a cursor deliver the results, if not, force loading the cursor
        if (mCursor != null) {
            deliverResult(mCursor);
        } else {
            forceLoad();
        }
    }

    @Override
    public void onStopLoading(){
        cancelLoad();
    }

    @Override
    public void onCanceled(ObjectCursor<T> cursor){
        if (cursor != null && !cursor.isClosed()) {
            cursor.close();
        }
    }

    @Override
    public void onReset(){
        super.onReset();
        // cancels loading
        onStopLoading();
        // if cursor isn't closed, close it
        if (mCursor != null && !mCursor.isClosed()) {
            mCursor.close();
        }
        // clear the reference to the cursor
        mCursor = null;
    }

}